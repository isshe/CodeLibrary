
# 设备初始化
记录一些设备初始化的信息。
> 由于是根据《深入理解Linux网络技术内幕》学习，因此相关设备是"网络设备"，不过相关流程应该具有一定通用性。

注册和初始化的任务一部分由内核完成，一部分由设备驱动程序完成。主要分为以下几个阶段：
* 硬件初始化
* 软件初始化
* 功能初始化

设备与内核交互方式：
* 轮询（polling）：由内核端驱动。
* 中断（interrupt）：由设备端驱动。

## 1.资源分配
设备驱动程序与内核通信的资源：
* IRQ线：设备用中断来通知内核一些事情。
    * 虚拟设备不需要分派一个IRQ，如回环设备。
    * 每个中断事件都会运行一个中断处理例程(interrupt handler)。
    * 相关函数：request_irq()/free_irq()
* I/O端口和内存注册：通常是将设备内存映射到系统内存，以方便读写。
    * 相关函数：request_region()/release_region()

## 2.虚拟设备分类
* 绑定（bonding）：绑定一组物理设备，使其如同单一设备。
* 802.1Q: 以VLAN报头扩充802.3/Ethernet帧头，因而得以建立VLAN。
* 桥接（bridging）：网桥的虚拟代表。
* 别名接口(aliasing interface): 支持单物理接口多IP。（现在代码改进，不用这个也能实现多IP）
* 普通均衡器（true equalizer, TEQL）: 这是队列规则，用于流量控制。其实现需要建立一个特殊设备。TEQL背后的思想有点类似Bonding。
* 隧道接口（tunnel interface）：IP-over-IP(IPIP)隧道以及GRE（Generalized Routing Encapsulation，通用路由封装）协议的实现基础是虚拟设备的建立。


### 3.参数分析(parse_arg)->两遍分析
内核为了兼容性，保留了两种关键字处理模型。先用新的对关键字进行处理，无法识别时，再用旧型基础架构予以处理。
再不能识别，则关键字和其值就会传给init进程。init内核线程结束时会通过`run_init_process`进行处理。
引导字符串的解析以及处理函数的调用分成两遍进行：
* 第一遍，只看必须在处理处理的较高优先级的选项，由一个特殊的表示(early)识别。
* 第二遍，负责所有其他选项。多数选项都属于这一类。旧模型的所有选项都会在这一遍处理。

新和旧的选项会放在两个不同的内存区域：
* `__setup_start...__setup_end`: 引导阶段结束后就会释放。
    * 所有旧的选项，无论是否设置`early`，都会放在这个区域。
* `__start___param...__stop___param`：不会释放，其内容会输出到/sys，使得这些选项可以展露给用户。



