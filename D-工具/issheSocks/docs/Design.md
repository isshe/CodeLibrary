

# 总体设计

## 第二版
```
+------------+            +----------+
| socks解析器 | (n)--->(n) | 代理服务器 |
+------------+            +----------+
```
* 代理服务器可以支持任意多级；只要配置好下一级
  * 第一版设计错了呀！

## 第一版
```
+------------+            +-------------+
| socks解析器 | (n)--->(n) | tunnel客户端 |
+------------+            +-------------+
                               (n)
                                ↓
                               (n)
  +----------+            +-------------+
  | 代理服务器 | (n)--->(n) | tunnel服务器 |
  +----------+            +-------------+
```
* socks解析器：解析socks5请求
* tunnel客户端：建立隧道，转发数据。
  * 可以连接指定个服务器（因此图中用1表示，常量）
  * 可以建立指定条隧道（因此图中用1表示）
  * 由于用途还是作为梯子，所以这里还是改为`n->n`，否则流量太大/维持长连接，可能引起墙的关注。
* tunnel服务器：接收隧道数据
* proxy服务器：负责代理请求

# socks解析器
## 需求
* 读取解析配置
* 开socks服务器，接受连接
* 开客户端，连接下一级，转发数据

## 过程
* 握手
  * event返回，接收到客户的连接(client_fd)
  * 进行socks5协议握手，进入已连接/数据转发状态
* 发送
  * client_fd可读，读event返回
  * 开启到下一跳的连接(next_fd)
  * 读取client_fd，转发到next_fd
* 接收
  * next_fd可读
  * 读取next_fd
  * 转发到client_fd

## 数据结构
```c

```

# 疑问
* DNS是否需要代理？
* 伪随机数如何生成？
* 假定不定长度，传输后如何知道长度？